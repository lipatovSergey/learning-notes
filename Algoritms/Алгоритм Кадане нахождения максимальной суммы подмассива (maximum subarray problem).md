#JS #JavaScript/algorithm #JavaScript 

Один из самых известных и эффективных алгоритмов для решения задачи нахождения **максимальной суммы подмассива** (maximum subarray problem). Он работает за время O(n) и использует O(1) дополнительной памяти, что делает его очень эффективным.

### Задача:

Дан массив чисел (возможно, с отрицательными числами). Необходимо найти непрерывный подмассив (последовательность элементов), сумма элементов которого максимальна.

#### Пример:

Для массива `[-2, 1, -3, 4, -1, 2, 1, -5, 4]` максимальная сумма подмассива равна `6`, и это подмассив `[4, -1, 2, 1]`.

---

### Основная идея алгоритма Кадане:

Алгоритм Кадане основан на динамическом программировании. Он проходит по массиву один раз, на каждом шаге принимая локально оптимальное решение, которое в итоге приводит к глобально оптимальному решению.

#### Ключевые моменты:

1. **Текущая сумма (`currentSum`)**: Сумма элементов подмассива, который мы рассматриваем на текущем шаге.
    
2. **Максимальная сумма (`maxSum`)**: Наибольшая сумма подмассива, которую мы нашли на данный момент.
    
3. **Локальный максимум**: На каждом шаге мы решаем, стоит ли добавлять текущий элемент к текущему подмассиву или начать новый подмассив с этого элемента.
    

---

### Алгоритм:

4. Инициализируем:
    
    - `currentSum = 0` (текущая сумма подмассива).
        
    - `maxSum = -Infinity` (или `0`, если пустой подмассив допустим).
        
5. Проходим по массиву:
    
    - На каждом шаге добавляем текущий элемент к `currentSum`.
        
    - Если `currentSum` становится отрицательной, сбрасываем её до `0` (или текущего элемента, если пустой подмассив недопустим).
        
    - Обновляем `maxSum`, если `currentSum` больше `maxSum`.
        
6. Возвращаем `maxSum`.
    

---

### Реализация на JavaScript:


```JavaScript
function maxSubarraySum(arr) {
  let currentSum = 0;
  let maxSum = -Infinity; // Или 0, если пустой подмассив допустим

  for (let i = 0; i < arr.length; i++) {
    currentSum += arr[i];
    
    // Если currentSum отрицательная, начинаем новый подмассив
    if (currentSum < 0) {
      currentSum = 0;
    }
    
    // Обновляем maxSum
    if (currentSum > maxSum) {
      maxSum = currentSum;
    }
  }

  return maxSum;
}
```
---

### Пример работы:

Рассмотрим массив: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`.

#### Шаги:

7. **i = 0**: `currentSum = -2` → сбрасываем до `0`, `maxSum = 0`.
    
8. **i = 1**: `currentSum = 1`, `maxSum = 1`.
    
9. **i = 2**: `currentSum = -2` → сбрасываем до `0`, `maxSum = 1`.
    
10. **i = 3**: `currentSum = 4`, `maxSum = 4`.
    
11. **i = 4**: `currentSum = 3`, `maxSum = 4`.
    
12. **i = 5**: `currentSum = 5`, `maxSum = 5`.
    
13. **i = 6**: `currentSum = 6`, `maxSum = 6`.
    
14. **i = 7**: `currentSum = 1`, `maxSum = 6`.
    
15. **i = 8**: `currentSum = 5`, `maxSum = 6`.
    

Результат: `maxSum = 6`.

---

### Почему алгоритм работает?

16. **Локальный максимум**: На каждом шаге мы выбираем, стоит ли добавлять текущий элемент к текущему подмассиву или начать новый подмассив. Это гарантирует, что мы не пропустим подмассив с максимальной суммой.
    
17. **Сброс `currentSum`**: Если `currentSum` становится отрицательной, это означает, что текущий подмассив "ухудшает" общую сумму, и мы начинаем новый подмассив с нуля (или с текущего элемента).
    

---

### Сложность:

- **Временная сложность**: O(n), где n — длина массива. Мы проходим по массиву только один раз.
    
- **Пространственная сложность**: O(1). Мы используем только несколько переменных.
    

---

### Когда использовать алгоритм Кадане?

18. **Задачи на подмассивы**: Если нужно найти подмассив с максимальной суммой.
    
19. **Ограничения по времени**: Когда требуется решение за O(n).
    
20. **Отрицательные числа**: Алгоритм корректно работает с массивами, содержащими отрицательные числа.
    

---

### Вариации алгоритма:

21. **С пустым подмассивом**: Если пустой подмассив допустим, то `maxSum` можно инициализировать как `0`.
    
22. **Без пустого подмассива**: Если пустой подмассив недопустим, то `maxSum` инициализируется как `-Infinity`, а `currentSum` сбрасывается не до `0`, а до текущего элемента.