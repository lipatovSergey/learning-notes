#React #documentation 
#### Проблема:

При обновлении состояния, основанного на предыдущем значении, в React может возникнуть проблема из-за асинхронности обновлений. Рассмотрим пример:

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);

  const handleAddTodo = (text) => {
    const newTodo = { id: Date.now(), text };
    setTodos([...todos, newTodo]); // Использует текущее значение todos
  };

  handleAddTodo("Task 1");
  handleAddTodo("Task 2");
}
```

Мы ожидаем, что получим:

```javascript
[{ id: ..., text: "Task 1" }, { id: ..., text: "Task 2" }]
```

Но на самом деле получаем:

```javascript
[{ id: ..., text: "Task 2" }]
```
#### Причина:

- В первом вызове `setTodos([...todos, newTodo])`, `todos` равен пустому массиву, так как это начальное значение состояния.
- Пока состояние не обновилось, второй вызов `setTodos([...todos, newTodo])` **также использует пустой массив**.
- Это происходит из-за того, что обновления состояния в React выполняются асинхронно, и второй вызов не дожидается завершения первого.

---

#### Решение:

Чтобы избежать этой проблемы, можно использовать **функцию обновления**:

```jsx
setTodos((prevTodos) => [...prevTodos, newTodo]);
```

В этом случае:

- React гарантирует, что `prevTodos` будет содержать **актуальное состояние** на момент вызова.
- Таким образом, каждый вызов `setTodos` добавляет новое значение к последнему обновлённому состоянию, независимо от асинхронности.

Пример с решением:

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);

  const handleAddTodo = (text) => {
    const newTodo = { id: Date.now(), text };
    setTodos((prevTodos) => [...prevTodos, newTodo]); // Используем функцию обновления
  };

  handleAddTodo("Task 1");
  handleAddTodo("Task 2");
}
```

Ожидаемый и реальный результат:

```javascript
[{ id: ..., text: "Task 1" }, { id: ..., text: "Task 2" }]
```

---

#### Почему функция обновления работает?

- Вместо использования `todos` из области видимости, React передаёт **текущее значение состояния** (`prevTodos`) в функцию обновления.
- Это гарантирует, что состояние всегда будет актуальным, даже если `setState` вызывается несколько раз подряд.

---

#### Рекомендация:

**Всегда используйте функцию обновления состояния, когда новое состояние зависит от предыдущего!** Это надёжный и безопасный способ избежать ошибок, связанных с асинхронностью обновлений.
