// Ключевое слово this указывает на контекст выполнения функции. Чтобы лучше понять, что такое контекст исполнения функции, сравним контекст с областью видимости.
// Область видимости статична и зависит от места инициализации функции (место где она написана). При исполнении функция помнит и может использовать все переменные из своей области видимости
const word = "Hello";
export function sayWord() {
	console.log(word);
}
// Поэтому если мы экспортируем sayWord в другой файл (1.js) и вызовем его там то в console получим "Hello" даже если определим новую переменную word с новым значением в 1.js то функция sayWord помнит и видит переменную word в своей области видимости. То-есть в этом файле.

// this ссылается на контекст. То есть на то место где функция исполняется. Например:
export function screamWord() {
	console.log(this.word.toUpperCase());
}
let helloScreamer = {
	word: "hello",
	scream: screamWord,
	say: sayWord,
};
helloScreamer.scream(); // HELLO
helloScreamer.say(); // Hello

let hiScreamer = {
	word: "hi",
	scream: screamWord,
	say: sayWord,
};
hiScreamer.scream(); // HI
hiScreamer.say(); // Hello
// Тут заметно что функция screamWord использующая this.word использует word из своего контекста (объекта в данном случае) где она была вызванна. Поэтому она будет возвращать разные значения при вызове в helloScreamer и hiScreamer при этом функция sayWord так и будет возвращать word со значением Hello, неважно где мы будем её вызывать в другом файле или внутри объекта. Она уже в своей памяти зафиксировала. word это только Hello.

// Важный момент. В нестрогом режиме вызов функции использующей .this на верхнем уровне вызовет ошибкую. Так как this будет undefined. Поэтопу для примера выше я использовал объекты.
// screamWord(); - такой вызов приведёт к ошибке Cannot read properties of undefined (reading 'word')
// в нестрогом режиме this в таком случае будет ссылаться на Window или global (Node.js)
