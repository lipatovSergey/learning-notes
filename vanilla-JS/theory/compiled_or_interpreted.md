деле происходит выполнение кода. Ни же пример того, как работает JS движок V8
### 1. **Парсинг (Parsing)**

- JS-код читается и **разбирается в AST** (Abstract Syntax Tree).
    
- На этом этапе ловятся **синтаксические ошибки**.
    
- Затем строится **"intermediate representation" (IR)** — промежуточное представление кода.
    

---

### 2. **Компиляция (Baseline / Bytecode)**

- Код компилируется в **байт-код**, который исполняется встроенной **виртуальной машиной**.
    
- Это **быстро**, но ещё не супер-оптимизировано.
    
- Используется **интерпретатор** (например, **Ignition** в V8), который запускает байт-код.
    

---

### 3. **Профилирование (Profiling)**

- Пока работает интерпретатор, движок **следит за выполнением кода**:
    
    - Какие функции вызываются часто?
        
    - Какие значения передаются?
        
    - Где можно что-то ные этапы прямо во время выполнения.ый, но его производительность достигается через умные копиляцион меняются типы) — движок **откатывается назад** и запускает интерпретатор снова.
    
- Это помогает сохранять баланс между **скоростью и гибкостью**.

Каждый этап еще будет подробно разобран в будущем. 
Благодаря такой архитектуре JS хоть и интерпертируемому", а потом резко стал "по-другому" (например,ующий компилятор** (например, **TurboFan**).
    
- Он делает **глубокую оптимизацию**:
    
    - Убирает лишние проверки типов
        
    - Превращает функции в низкоуровневый машинный код
        
- Оптимизированный код **кэшируется и переиспользуется**
    

---

### 5. **Деоптимизация (если нужно)**

- Если код вёл себя "по однускорить?
        

---

### 4. **[[JIT (Just-In-Time) компиляция в JS(V8)]]** 

- "Горячие участки кода" (те, что часто выполняются) отправляются в **оптимизирболее сложная. Вот как на самом ## Компилируемый код
Требует предварительной компиляции в машинный или байт код перед запуском. Результатом компиляции становиться исполняемый файл (.exe .out и т.п.). Эти файлы запускаються без исходника. И распространяются обычно именно исполняемые файлы. 

## Интерперетируемый код
Исполняется напрямую интерпретатором построчно, без предварительной компиляции в исполняемый файл. В этом случае распространяется сам исходник.

Но! Важно понимать. На техническом уровне, почти все современные языки имеют этап компиляции. Поэтому деление на "компелируемые" и "интерперетируемые" - это юольше вопрос распространения и запуска. 

# Так куда отнести JS?
В плане распространения JS однозначно интерпретируемый. Распространяются и запускаются сами .js файлы. Но в плане исполнения, не всё так однозначно.
В книге "Вы не знаете JS " автор приводит несколько примеров которые идут в разрез с определением интерпретируемого кода.
Пример 1
```JS
var greeting = "Hello"
console.log(greeting)
greeting = ."Hi" // специально допущенная ошибка
```
Из определения интерпретируемого кода следует, что он исполняется построчно. Значит в этом случае мы должны были сначала получить вывод в консоль, а затем сообщение об ошибке. На самом же деле при запуске программы мы сразу полуим сообщение об ошибке <span style="background:#ff4d4f">SyntaxError: unexpected token</span>. Значит движок JS может узнать об ошибке в третьей строке, перед выполнением кода в первой строке. Значит движок сначала разбирает программу до того, как будет выполнена любая из её частей.
Пример 2
```js
console.log("Howdy");
saySomething("Hello","Hi");
// Неперехваченная ошибка SyntaxError: одинаковые имена
// параметров недопустимы в этом контексте
function saySomething(greeting,greeting) {
"use strict";
console.log(greeting);
}
```
И опять мы сразу получим ошибку, а не вывод в консоль. 

### Тогда, что же происходит на самом деле? 
На самом деле современная архитектра языков таких как JS куда 
