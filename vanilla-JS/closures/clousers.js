// greeting тут является фабрикой.
function greeting(msg) {
  return function who(name) {
    console.log(`${msg}, ${name}!`);
  };
}
var hello = greeting("Hello");
var howdy = greeting("Howdy");
hello("Kyle"); // Hello, Kyle!
hello("Sarah"); // Hello, Sarah!
howdy("Grant"); // Howdy, Grant!
// Обычно когда фабрика закончила свою работу. Все переменные использованные в ней должны были исчезнуть.
// Но благодаря замыканиям даже после исчезновения фабрики функции hello и howdy всё ещё помнят переменную msg которую им дали на фабрике.
// Важно понимать! Это не просто копия значения а именно ссылка на него.

function createCounter(initialValue) {
  let count = initialValue; // Начальная сумма в ячейке
  function increment() {
    count = count + 1; // Увеличение суммы
    console.log(count);
  }
  return increment; // Банк выдает вам вашу ячейку
}
let counterA = createCounter(10); // Вы получаете ячейку, начинающуюся с 10
let counterB = createCounter(5); // Другой человек получает ячейку с 5
counterA(); // Вы кладете в свою ячейку еще денег -> 11
counterA(); // Еще раз -> 12
counterB(); // Другой человек кладет в свою ячейку -> 6

// Этот пример более наглядно показывает почему counterA и counterB получают именно ссылку на initial value. Если бы это была копия то при вызове counterA значение внутри count просто увеличивалось бы на 1. Но это никак не повлияло бы на исходную переменную initialValue в функции createCounter. Но благодаря замыканию counterA хранит в себе ссылку на ту переменную count котороя была создана именно в том вызове когда counterA была создана
// Именно поэтому при каждом вызове createCounter создается новое "замыкание" с новой, независимой переменной count. counterA работает со своей собственной count, а counterB — со своей.

// Пример поясняющий что при замыкании в новой функции храниться именно ссылка на внешнюю переменную с переданным в неё при инициализации значением, а не просто значение (мгновенный снимок)
function outer() {
  let message = "Привет";
  function inner() {
    console.log(message);
  }
  message = "Пока"; // Изменяем значение переменной ДО возврата inner
  return inner;
}
let myFunc = outer();
myFunc(); // "Пока"
// Благодаря тому, что myFunc хранит именно ссылку на переменную message, значение этой переменной может быть измененно. Если бы это был "мгновенный снимок" (просто значение переменной) мы бы получили "Привет" при вызове myFunc, но так, как значение message было измененно перед возвратом внутренней функции inner то мы в консоль будет выведенно изменённое значение

// Внешняя область видимости необязана быть функцией.Важно лишь то, чтобы во внешней области видимости была как минимум одна переменная, к которой происходит обращение из внутренней функции. Например:
for (let [idx, btn] of buttons.entries()) {
  btn.addEventListener("click", function onClick() {
    console.log(`Clicked on button (${idx})!`);
  });
}
// Так как в объявлении цикла используется let, то каждый итерратор получает новые переменные idx и btn. С блоковой (локально) областью видимости. Внутренняя функци замыкается по переменной idx, тоесть каждая кнопка получает свой обработчик со своим значение idx.
